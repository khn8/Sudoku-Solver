.data
space: .asciiz "\n"

.text
	jal	_readBoard 
	move    $a0, $zero            # Offset of first cell to guess
	jal	_solve
	
	j	exit

exit:
    move    $a0, $s0              # Store return code in $a0
    li      $v0, 17               # load exit2 syscall number in $v0
    syscall                       # Execute the syscall

# _readBoard
#
# Read the board generated by the Sudoku tool
#
# Argument:
#   None
# Return Value:
#  None
_readBoard:
	addi $t0, $zero, 0xFFFF8000		#$t0 as the first place in the board
	addi $t1, $zero, 0xFFFF8051		#$t1 as the last place in the board
	add $t3, $zero, $zero
	j	readLoop
readLoop:
	lb $t4, 0($t0)			#Load current data in $t0 into $t3
	add  $a0, $zero, $t4	# Put $t3 to $a0 (to print on the console)
	addi $v0, $zero, 1		# Syscall 1: Print integer
	syscall				# Print integer
	addi $t0, $t0, 1
	addi $t3, $t3, 1
	beq $t3, 9, newLine
	
	bne $t0, $t1, readLoop
	j	readDone
newLine:
	add $t3, $zero, $zero
	addi $v0, $zero, 4  # Print_string syscall
    	la $a0, space       	# Load address of the string
    	syscall
    	beq $t0, $t1, readDone
    	j	readLoop
readDone:
	jr $ra

# _solve
#
# Solve for the correct input
#
# Argument:
# $a0 - The current position being tested
# Return Value:
# $v0 - 0 if the result is false, 1 if it's true
_solve:
	addi $sp, $sp, -20		# Allocate activation frame
	sw $ra, 16($sp)          	# Save the return address
    	sw $s3, 12($sp)          	# Save the $s3 register
    	sw $s2, 8($sp)           	# Save the $s2 register
    	sw $s1, 4($sp)           	# Save the $s1 register
    	sw $s0, 0($sp)           	# Save the $s0 registerra

	move    $s0, $a0              # Save the argument in $s0
   	beq     $s0, 81, solveSucc # Check if offset's outside the board's bounds

    	# Get current cell's row and column indexes
    	addi      $t8, $zero, 9    	# Store the board size in $s3
    	div     $s0, $t8              # Divide the cell's offset by the board size
    	mflo    $s1                   # $s1 = cell's row index
    	mfhi    $s2                   # $s2 = cell's column index
    	addi     $s3, $zero, 1   # $s3 = Start at 1 (to 9)          
	
	# Check if the current cell is empty
    	addi $t9, $s0, 0xFFFF8000		#$t9 as the first place in the board
    	lb      $t0, 0($t9)   # Load current cell's value in $t0
    	beqz    $t0, solveLoop       # If the cell is empty, start guessing
    	addi    $a0, $s0, 1           # Otherwise, increment the offset
    	jal     _solve                 #   and go on to the next cell
    	j       solveReturn             # Return the value returned by guess()

solveLoop:
    	# Check if the value in $s3 is a legal candidate for this cell
    	move    $a0, $s3              # $a0 = the number to check 
    	move    $a1, $s1              # $a1 =  row index 
    	move    $a2, $s2              # $a2 = column index 
   	jal     check                 # Check if the current number is eligible
    	bne    $v0, 1, solveFail # If _check return 0 (fail), go to solveFail
    	addi $t9, $s0, 0xFFFF8000		#$t9 as the first place in the board
    	sb      $s3, 0($t9)   # If OK, assign number to cell
    	# Go on to the next cell
    	addi    $a0, $s0, 1           # Increment the current position
    	jal     _solve                 # Recursively call _solve
    	beq    $v0, 1, solveReturn        # Return if _solve succeeded

solveFail:
    	addi     $s3, $s3, 1                # Decrement the number to test
    	bne    $s3, 10, solveLoop      
    	addi $t9, $s0, 0xFFFF8000	# $t9 as the first place in the board
    	sb      $zero, 0($t9) # If no number worked, empty the cell
    	li      $v0, 0                # Return 0 if fail
    	j       solveReturn            # Jump to return instructions

solveSucc:
    	addi   $v0, $zero, 1            # Return 1 if success
    	
solveReturn:
    # Destroy the stack frame
    lw      $s0, 0($sp)          # Restore the $s0 register
    lw      $s1, 4($sp)          # Restore the $s1 register
    lw      $s2, 8($sp)          # Restore the $s2 register
    lw      $s3, 12($sp)        # Restore the $s3 register
    lw      $ra, 16($sp)        # Restore the return address
    addi    $sp, $sp, 20      # Clean up the stack
    jr      $ra                   # Return

# _check 
# Check if a number is the right one to put in cell                                  
#                                                                                                                                              
# Arguments:                                                                   
#   $a0 - Number to check                                                      
#   $a1 - Row                                                     
#   $a2 - Column                                                
# Registers used:                                                              
#   None    
check:
    # Row check
    addi      $t0, $zero, 9                # Set counter
    mul     $t1, $a1, $t0         # Offset of the first cell in the row
    
checkRow:
    addi $t9, $t1, 0xFFFF8000		#$t9 as the first place in the board
    lb      $t2, 0($t9)   # Value in the current cell
    beq     $a0, $t2, checkFail  # Number already present in row
    addi    $t1, $t1, 1           # Increment the pointer to the current cell
    sub     $t0, $t0, 1           # Decrement the counter
    bnez    $t0, checkRow        # Check the next cell in the row

    # Column check
    add    $t1, $zero, $a2              # Offset of the first cell in the column 
checkCol:
    addi $t9, $t1, 0xFFFF8000		#$t9 as the first place in the board
    lb      $t2, 0($t9)   # Value of the current cell
    beq     $a0, $t2, checkFail  # Number already present in column
    addi    $t1, $t1, 9           # Increment the pointer to the current cell
    ble     $t1, 81, checkCol    # Check the next cell in the column

    # 3x3-Box check
    div     $t0, $a1, 3           # $t0 = row / 3
    mul     $t0, $t0, 27          # Offset of the row
    div     $t1, $a2, 3           # $t1 = col / 3
    mul     $t1, $t1, 3           # Offset of the column
    add     $t1, $t0, $t1         # Offset of the first cell in the box

    addi      $t0, $zero, 3                # Set up the row counter
    addi      $t3, $zero, 3               # Set up the column counter
checkBox:
    addi $t9, $t1, 0xFFFF8000		#$t9 as the first place in the board
    lb      $t2, 0($t9)   # Value of the current cell
    beq     $a0, $t2, checkFail  # Number already present in column
    sub     $t3, $t3, 1           # Decrement the column counter
    beqz    $t3, endBox      # Check if end of current box row is reached
    addi    $t1, $t1, 1           # Increment the pointer to the current cell
    j       checkBox             # Check the next cell in the row
endBox:
    addi    $t1, $t1, 7           # Increment the pointer to the current cell
    li      $t3, 3                # Reset the column counter
    sub     $t0, $t0, 1           # Decrement the row counter
    bnez    $t0, checkBox        # Check if end of box is reached

    addi    $v0, $zero, 1            # Return code is 0 (success)
    j       checkReturn             

checkFail:
    addi      $v0, $zero, 0                # Return code is 1 (failure)

checkReturn:
    jr      $ra                   # Return
